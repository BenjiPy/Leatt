"""Main daemon orchestrating all monitors."""

import threading
import time
from typing import Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
from queue import Queue

from ..utils.logger import get_logger
from ..utils.config import get_config
from ..utils.database import get_database, AlertSeverity
from ..utils.platform import PlatformUtils

logger = get_logger("daemon")


class DaemonState(str, Enum):
    STOPPED = "stopped"
    STARTING = "starting"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"


@dataclass
class MonitorEvent:
    """Event generated by monitors."""
    source: str
    event_type: str
    data: dict
    timestamp: float = field(default_factory=time.time)
    risk_score: float = 0.0


class LeattDaemon:
    """Main daemon that orchestrates all monitoring components."""
    
    def __init__(
        self,
        enable_systray: bool = True,
        enable_web: bool = False,
    ):
        self.config = get_config()
        self.db = get_database()
        
        self.enable_systray = enable_systray
        self.enable_web = enable_web
        
        self.state = DaemonState.STOPPED
        self._stop_event = threading.Event()
        self._event_queue: Queue[MonitorEvent] = Queue()
        
        self._monitors: dict = {}
        self._threads: list[threading.Thread] = []
        
        self._event_handlers: list[Callable[[MonitorEvent], None]] = []
        
        self._systray = None
        self._web_server = None
        
        self._start_time: float = 0.0
        self._grace_period_seconds: float = 30.0
    
    def _init_monitors(self) -> None:
        """Initialize monitoring components."""
        from .process_monitor import ProcessMonitor
        from .file_monitor import FileMonitor
        from .network_monitor import NetworkMonitor
        
        if self.config.process_monitoring_enabled:
            self._monitors["process"] = ProcessMonitor(
                event_queue=self._event_queue,
                stop_event=self._stop_event,
                interval=self.config.process_interval,
            )
            logger.info("Process monitor initialized")
        
        if self.config.file_monitoring_enabled:
            watched_folders = [
                PlatformUtils.expand_path(p)
                for p in self.config.watched_folders
            ]
            self._monitors["file"] = FileMonitor(
                event_queue=self._event_queue,
                stop_event=self._stop_event,
                watched_folders=watched_folders,
            )
            logger.info("File monitor initialized")
        
        if self.config.network_monitoring_enabled:
            self._monitors["network"] = NetworkMonitor(
                event_queue=self._event_queue,
                stop_event=self._stop_event,
                interval=self.config.network_interval,
            )
            logger.info("Network monitor initialized")
        
        if self.config.registry_monitoring_enabled and PlatformUtils.registry_available():
            from .registry_monitor import RegistryMonitor
            self._monitors["registry"] = RegistryMonitor(
                event_queue=self._event_queue,
                stop_event=self._stop_event,
            )
            logger.info("Registry monitor initialized")
    
    def _init_detection(self) -> None:
        """Initialize detection engines."""
        from ..detection.rules_engine import RulesEngine
        from ..detection.heuristics import HeuristicsEngine
        
        self._rules_engine = RulesEngine()
        self._heuristics_engine = HeuristicsEngine()
        
        if self.config.ml_enabled:
            from ..detection.ml_detector import MLAnomalyDetector
            self._ml_detector = MLAnomalyDetector()
            logger.info("ML anomaly detector initialized")
        else:
            self._ml_detector = None
    
    def _init_ui(self) -> None:
        """Initialize UI components."""
        if self.enable_systray:
            from ..ui.systray import SystrayApp
            self._systray = SystrayApp(
                on_pause=self.pause,
                on_resume=self.resume,
                on_quit=self.stop,
            )
            logger.info("Systray initialized")
        
        if self.enable_web:
            from ..web.app import WebDashboard
            self._web_server = WebDashboard(
                host=self.config.web_host,
                port=self.config.web_port,
            )
            logger.info(f"Web dashboard initialized at http://{self.config.web_host}:{self.config.web_port}")
    
    def _event_processor(self) -> None:
        """Process events from the queue."""
        while not self._stop_event.is_set():
            try:
                event = self._event_queue.get(timeout=1.0)
                self._process_event(event)
            except Exception:
                continue
    
    def _process_event(self, event: MonitorEvent) -> None:
        """Process a single event through detection engines."""
        if self.state == DaemonState.PAUSED:
            return
        
        in_grace_period = (time.time() - self._start_time) < self._grace_period_seconds
        
        alerts = self._rules_engine.evaluate(event)
        
        heuristic_alerts = self._heuristics_engine.analyze(event)
        alerts.extend(heuristic_alerts)
        
        if self._ml_detector and self._ml_detector.is_trained:
            anomaly_score = self._ml_detector.predict(event)
            if anomaly_score > 0.7:
                alerts.append({
                    "severity": AlertSeverity.HIGH,
                    "source": "ml_detector",
                    "description": f"Anomalous behavior detected (score: {anomaly_score:.2f})",
                })
        
        for alert in alerts:
            self.db.add_alert(
                severity=alert["severity"],
                source=alert["source"],
                description=alert["description"],
                process_name=event.data.get("process_name"),
                process_pid=event.data.get("pid"),
                details=str(event.data),
            )
            
            if self._systray and self.config.notifications_enabled and not in_grace_period:
                if alert["severity"] in (AlertSeverity.HIGH, AlertSeverity.CRITICAL):
                    self._systray.notify(
                        title=f"Leatt Alert [{alert['severity'].value.upper()}]",
                        message=alert["description"],
                    )
        
        for handler in self._event_handlers:
            try:
                handler(event)
            except Exception as e:
                logger.error(f"Event handler error: {e}")
    
    def add_event_handler(self, handler: Callable[[MonitorEvent], None]) -> None:
        """Add a custom event handler."""
        self._event_handlers.append(handler)
    
    def start(self) -> None:
        """Start the daemon and all monitors."""
        if self.state != DaemonState.STOPPED:
            logger.warning(f"Cannot start daemon in state {self.state}")
            return
        
        self.state = DaemonState.STARTING
        self._start_time = time.time()
        logger.info("Starting Leatt daemon...")
        logger.info(f"Grace period: {self._grace_period_seconds}s (no notifications during initial scan)")
        
        self._init_monitors()
        self._init_detection()
        self._init_ui()
        
        processor_thread = threading.Thread(
            target=self._event_processor,
            name="EventProcessor",
            daemon=True,
        )
        processor_thread.start()
        self._threads.append(processor_thread)
        
        for name, monitor in self._monitors.items():
            thread = threading.Thread(
                target=monitor.start,
                name=f"Monitor-{name}",
                daemon=True,
            )
            thread.start()
            self._threads.append(thread)
            logger.debug(f"Started {name} monitor thread")
        
        if self._web_server:
            web_thread = threading.Thread(
                target=self._web_server.run,
                name="WebServer",
                daemon=True,
            )
            web_thread.start()
            self._threads.append(web_thread)
        
        self.state = DaemonState.RUNNING
        logger.info("Leatt daemon started successfully")
        
        if self._systray:
            self._systray.run()
        else:
            while not self._stop_event.is_set():
                time.sleep(1)
    
    def stop(self) -> None:
        """Stop the daemon and all monitors."""
        if self.state in (DaemonState.STOPPED, DaemonState.STOPPING):
            return
        
        self.state = DaemonState.STOPPING
        logger.info("Stopping Leatt daemon...")
        
        self._stop_event.set()
        
        for name, monitor in self._monitors.items():
            try:
                monitor.stop()
                logger.debug(f"Stopped {name} monitor")
            except Exception as e:
                logger.error(f"Error stopping {name} monitor: {e}")
        
        if self._systray:
            self._systray.stop()
        
        if self._web_server:
            self._web_server.stop()
        
        for thread in self._threads:
            thread.join(timeout=5.0)
        
        self.state = DaemonState.STOPPED
        logger.info("Leatt daemon stopped")
    
    def pause(self) -> None:
        """Pause monitoring (alerts still logged but not processed)."""
        if self.state == DaemonState.RUNNING:
            self.state = DaemonState.PAUSED
            logger.info("Monitoring paused")
            if self._systray:
                self._systray.set_status("paused")
    
    def resume(self) -> None:
        """Resume monitoring."""
        if self.state == DaemonState.PAUSED:
            self.state = DaemonState.RUNNING
            logger.info("Monitoring resumed")
            if self._systray:
                self._systray.set_status("running")
    
    @property
    def is_running(self) -> bool:
        return self.state == DaemonState.RUNNING
    
    @property
    def is_paused(self) -> bool:
        return self.state == DaemonState.PAUSED
